<!DOCTYPE html>
<html>
<head>
    <title>An event center for .NET Core in C# - NaNday.dev</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <META HTTP-EQUIV="CACHE-CONTROL" CONTENT="NO-CACHE">
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <script src="/js/highlight.pack.js"></script>
    <link rel="stylesheet" href="/css/code.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-115180098-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-115180098-1');
    </script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body id="dotnet-event-center">

<nav>
<section>
    <span class="home">
        <a href="/">Home</a>
    </span>
    <span class="links">
        <a href="/blog/">Blog</a>
        <!-- <a href="/news/">News</a> -->
        <a href="/contact/">Contacts</a>
        <!-- <a href="/about/">About</a> -->
    </span>
</section>
</nav>

<main>
<article>
<h1><a href="/blog/dotnet-event-center/">An event center for .NET Core in C#</a></h1>
<p class="meta">Published on 2020-12-15 by <b>nanday.dev</b></p>
<div align="center"><img class="post-hero-images" src="../../images/george_marty_pc.jpg"/></div>
<p class="post-hero-comment">Marty is startled! George... nah.</p>
<p><b>Many times, in different kinds of applications written in C#, I found myself in need for a quick way to make two or more objects, no matter the nature of them, receive and send simple events occurring in any moment</b>.</p>
<p>For instance, working with WPF, there were times where an obscure, small button hidden somewhere under layers of framework elements, needed to receive instant notifications about something happening somewhere else, maybe in a long-running service, and I didn't like the thought having any of them tightly coupled to the other.</p>
<p>So, I solved the issue with a sort of "Notification Center", and month after month improved the implementation, making it more generic, since I needed the same class on more projects, and of course not every application has to send the same messages. At the same time, having it TOO much generic wouldn't be really helpful too, having to do with too many casts and check.</p>
<p><b>This is the sweet "middle spot" I found for the implementation.</b></p>
<p>First of all, the class will be static, and have a generic type, which is going to be an enum. The enum is going to include all the events the application components can launch and receive, and thus should be specific to each application.</p>
<p>It will consist of a static dictionary, containing, for each element of the enum, a list of <span class="post-key-classname">Action</span> to perform when the event is fired; and three functions, two to subcribe or unsubscribe to the events, and one to notify a change in the specific event.</p>
<p>Let's start with the dictionary.</p>
<pre><code>using System;
using System.Collections.Generic;
using System.Linq;

public static class NotificationCenter&lt;TEnum&gt; where TEnum : Enum
{
    private static readonly Dictionary&lt;TEnum, List&lt;Action&lt;object&gt;&gt;&gt; _eventDictionary = CreateDictionary();

    private static Dictionary&lt;TEnum, List&lt;Action&lt;object&gt;&gt;&gt; CreateDictionary()
    {
        var dictionary = new Dictionary&lt;TEnum, List&lt;Action&lt;object&gt;&gt;&gt;();
        foreach(TEnum enumElement in Enum.GetValues(typeof(TEnum)).Cast&lt;TEnum&gt;())
            dictionary[enumElement] = new List&lt;Action&lt;object&gt;&gt;&gt;();
        return dictionary;
    }
}
</code></pre>
<p>As you can see, we initialized the dictionary, and filled it with key-value pairs for each of the enum elements, no matter what enum you're providing to the class, and then initializing for each a new list of Actions&lt;object&gt;</p>
<p>Let's now see the "subscribe" and "unsubscribe" functions.</p>
<pre><code>public static void SubscribeToEvent(TEnum appEvent, Action&lt;object&gt; action) 
{
    _eventDictionary[appEvent].Add(action);
}
public static void UnsubscribeToEvent(TEnum appEvent, Action&lt;object&gt; action)
{
    _eventDictionary[appEvent].Remove(action);
}
</pre></code>
<p>These functions simply fetch the list of actions from the dictionary and add or remove the given action.</p>
<p>Now for the "notify" function</p>
<pre><code>public static void NotifyEventChanged(TEnum appEvent, object parameter)
{
    foreach(var action in _eventDictionary[appEvent])
        action?.Invoke(parameter);
}
</pre></code>
<p>So, notifying means again fetching the list of actions, and invoking each of them with the parameter object... provided they are not null.</p>
<p><b>Let's see a usage sample now.</b></p>
<p>Let's say we're developing an application to monitor some anti-intrusion sensor in our facility. We could write this simple enum, containing some events that could happen in the application.</p>
<pre><code>public enum SensorAppEvent
{
    ENTRANCE_SENSOR_STATUS_CHANGED = 0,
    BATHROOM_SENSOR_STATUS_CHANGED = 1,
    BATHROOM_BATTERY_SENSOR_LOW = 2,
    ...
}
</pre></code>
<p>A view we show to the user to let him know when sensors change status could do this, in its constructor:</p>
<pre><code>public class MainView : View
{
    public MainView()
    {
        NotificationCenter&lt;SensorAppEvent&gt;.SubscribeToEvent(
            SensorAppEvent.ENTRANCE_SENSOR_ENABLED_CHANGED, 
            OnEntranceSensorChanged);
    }

...

    private void OnEntranceSensorChanged(object parameter)
    {
        // Here we can cast the parameter to the type of object we expect
        // and react accordingly //
        // ... //
    }
</pre></code>
<p>Somewhere else, in a class which is at a lower level and receives some raw info from the sensor, could do this, when it parses that info and realizes the sensor just changed status:</p>
<pre><code>NotificationCenter&lt;SensorAppEvent&gt;.NotifyEventChanged(
    SensorAppEvent.ENTRANCE_SENSOR_ENABLED_CHANGED, 
    new SensorEvent(...));
</pre></code>
<p>The above MainView class would receive the event as soon as it happens and react accordingly.</p>
<p>Please note, while implementing this, that the events are notified on the same thread as the caller of NotifyEventChanged. Also, remember to call the UnsubcribeToEvent function, or else memory leaks and weird behaviours may happen!</p>
<p>The full source code is available <a href="../../code_snippets/EventCenter.cs">here</a>.</p>
</article>

</main>

<footer>
<section>
<p>&copy; 2020 NaNday.Dev</p>
<p>
    <a href="https://www.linkedin.com/in/ðŸ’»-guido-cardinali-2aba9b104/">LinkedIn</a>
    <a href="https://github.com/NandayDev">GitHub</a>
</p>
</section>
</footer>

</body>
</html>
